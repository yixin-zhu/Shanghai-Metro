\documentclass[12pt,letterpaper]{article}
\usepackage{fullpage}
\usepackage[top=2cm, bottom=4.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd}
\usepackage{lastpage}
\usepackage{enumerate}
\usepackage{fancyhdr}
\usepackage{mathrsfs}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{float}
\usepackage{longtable}
\usepackage[UTF8]{ctex}
\usepackage[utf8]{inputenc}
\usepackage{subfigure}
\usepackage{amsmath}

\hypersetup{%
	colorlinks=true,
	linkcolor=blue,
	linkbordercolor={0 0 1}
}

\renewcommand{\familydefault}{\rmdefault}
\renewcommand\lstlistingname{代码}
\renewcommand\lstlistlistingname{Algorithms}
\def\lstlistingautorefname{Alg.}

\lstdefinestyle{C++}{
	language        = C++,
	frame           = single, 
	basicstyle      = \footnotesize,
	keywordstyle    = \color{blue},
	numbers         = none,
	stringstyle     = \color{orange},
	commentstyle    = \color{red}\ttfamily
	funtionstyle    = \color{purple},
	numbers         = left,
	columns         = fixed,
	xleftmargin		= 0em,
}

\lstdefinestyle{Python}{
	language        = Python,
	frame           = single, 
	basicstyle      = \footnotesize,
	keywordstyle    = \color{blue},
	numbers         = none,
	stringstyle     = \color{orange},
	commentstyle    = \color{red}\ttfamily
	funtionstyle    = \color{purple},
	numbers         = left,
	columns         = fixed,
	xleftmargin		= 0em,
}

\setlength{\parindent}{0.0in}
\setlength{\parskip}{0.0in}

\newcommand\course{数据结构}
\newcommand\hwnumber{2实验报告}                  
\newcommand\NetIDa{朱奕新}
\newcommand\NetIDb{19307090029}         

\pagestyle{fancyplain}
\headheight 35pt
\lhead{\NetIDa}
\lhead{\NetIDa\\\NetIDb}               
\chead{\textbf{\Large Project \hwnumber}}
\rhead{\course \\ 2021年12月21日}
\lfoot{}
\cfoot{}
\rfoot{\small\thepage}
\headsep 1.5em

\begin{document}
	\section{项目说明}
\begin{enumerate}
	\item 本次实验使用Python语言，实现了Bellman-Ford与Dijkstra两种单源最短路径算法。
	\item 程序分为普通版和UI版。普通版在控制台输入和输出；UI版则用一个UI界面与用户互动，具体使用方法请参见Readme.md文件。两个版本核心算法思想与实现没有本质不同，仅仅是函数返回结果的形式有差异。
	\item 本实验报告以普通版代码为例进行设计的介绍。
\end{enumerate}	
\section{设计思路与实现细节}
\subsection{点类与边类}
\begin{enumerate}
	\item 一个结点需要，还需要。
	\item 一条边需要，还需要。
\end{enumerate}
\lstset{caption={红黑树结点类}}
\lstset{label={lst:alg1}}
\begin{lstlisting}[style = Python]
class RBnode:
	color = BLACK
	key = None
	left = None
	right = None
	p = None
	part = None
	frequency = None

def __init__(self, newKey=None, newPart=None, newFrequency=None):
	self.key = newKey
	self.part = newPart
	self.frequency = newFrequency
\end{lstlisting}
\lstset{caption={NIL结点作为红黑树类的成员变量}}
\lstset{label={lst:alg2}}
\begin{lstlisting}[style = Python]
class RBtree:
    root = RBnode()
    __nil = RBnode()
\end{lstlisting}

\subsection{边的松弛}
\begin{enumerate}
	\item 旋转用来调整红黑树的结构，分为左旋与右旋。一般用来帮助其他函数的实现。
\end{enumerate}
\lstset{caption={左旋函数}}
\lstset{label={lst:alg3}}
\begin{lstlisting}[style = Python]
    def leftRotate(self, x):
        y = x.right
        x. right = y.left
        if(y.left != self.__nil):
            y.left.p = x
        y.p = x.p
        if(x.p == self.__nil):
            self.root = y
        elif(x == x.p.left):
            x.p.left = y
        else:
            x.p.right = y
        y.left = x
        x.p = y
\end{lstlisting}
\lstset{caption={右旋函数}}
\lstset{label={lst:alg4}}
\begin{lstlisting}[style = Python]
    def rightRotate(self, y):
        x = y.left
        y. left = x.right
        if(x.right != self.__nil):
            x.right.p = y
        x.p = y.p
        if(y.p == self.__nil):
            self.root = x
        elif(y == y.p.left):
            y.p.left = x
        else:
            y.p.right = x
        x.right = y
        y.p = x
\end{lstlisting}

\subsection{Bellman-Ford算法}
\begin{enumerate}
	\item 要插入结点z，就从根节点开始向下找到它要插入的位置，认适当的结点做父亲；然后设置自己的两个孩子为NIL，设置自己为红色；最后对自己调用辅助程序insertFixup函数重新着色和旋转，使红黑树整体的性质得以保存。
	\item 当父亲结点为红色时，这是不行的，就需要继续执行。假定父亲是爷爷的左孩子，insertFixup()函数分三种情况来修正。
	\item 如果叔叔为红色，就让父亲和叔叔变黑、让爷爷变红，并前往爷爷结点处继续递归。
	\item 如果叔叔为黑色，且我是右孩子，则前往父亲处左旋。这种情况会转化为下一种情况。
	\item 如果叔叔为黑色，且我是左孩子，则使父亲变黑，爷爷变红，并在爷爷处右旋。
	\item 如果父亲是爷爷的右孩子，以上左右互换。
	\item 最后，将根结点染黑。
\end{enumerate}
\lstset{caption={插入函数}}
\lstset{label={lst:alg5}}
\begin{lstlisting}[style = Python]
    def insertNode(self, z):
        y = self.__nil
        x = self.root
        while(x != self.__nil):
            y = x
            if (z.key < x.key):
                x = x.left
            elif(z.key > x.key):
                x = x.right
            else:
                print("Key", z.key, "conflict", )
                return
        z.p = y
        if(y == self.__nil):
            self.root = z
        elif(z.key < y.key):
            y.left = z
        else:
            y.right = z
        z.left = self.__nil
        z.right = self.__nil
        z.color = RED
        self.insertFixup(z)

    def insert(self, k, p, f):
        z = RBnode(k, p, f)
        self.insertNode(z)    
\end{lstlisting}

\lstset{caption={insertFixup函数}}
\lstset{label={lst:alg6}}
\begin{lstlisting}[style = Python]
    def insertFixup(self, z):
        while(z.p.color == RED):
            y = self.uncle(z)
            if(y.color == RED):
                z.p.color = BLACK
                y.color = BLACK
                z.p.p.color = RED
                z = z.p.p
            else:
                if(z.p == z.p.p.left):
                    if(z == z.p.right):
                        z = z.p
                        self.leftRotate(z)
                    z.p.color = BLACK
                    z.p.p.color = RED
                    self.rightRotate(z.p.p)
                else:
                    if(z == z.p.left):
                        z = z.p
                        self.rightRotate(z)
                    z.p.color = BLACK
                    z.p.p.color = RED
                    self.leftRotate(z.p.p)
        self.root.color = BLACK
\end{lstlisting}

\subsection{Dijkstra算法}
\begin{enumerate}
	\item 要删除结点z，要用到辅助函数transplant()，用v子树来替换u子树。
	\item 删除操作类似于普通搜索树的删除，分为三种情况进行。但是删除之后要使用deleteFixup()函数，通过改变颜色和执行旋转来恢复红黑性质。
	\item deleteFixup()函数分四种情况来修正。当我是父亲的左子时：
	\item 如果兄弟红，就染黑它，染红父亲，并在父亲左旋。去新的兄弟处递归执行。
	\item 如果兄弟黑，且其两孩子都黑，则染红兄弟。去父亲递归执行。
	\item 如果兄弟w黑，且其子左红右黑，则使其与其左子交换颜色，并在w处右旋。此时进入第四种情况。
	\item 取新的兄弟w。若兄弟之右子红，则染黑父亲，染黑兄弟右子，在父亲处左旋。
	\item 如果我是父亲的右孩子，以上左、右互换。
	\item 最后，将自己染黑。
\end{enumerate}
\lstset{caption={删除函数}}
\lstset{label={lst:alg7}}
\begin{lstlisting}[style = Python]
    def delete(self, i):
        z = self.find(i)
        if(z == self.__nil):
            print('Key', i, 'missing')
            return
        else:
            y = z
            yOriginalColor = y.color
            if(z.left == self.__nil):
                x = z.right
                self.transplant(z, z.right)
            elif(z.right == self.__nil):
                x = z.left
                self.transplant(z, z.left)
            else:
                y = self.minimum(z.right)
                yOriginalColor = y.color
                x = y.right
                if(y.p == z):
                    x.p = y
                else:
                    self.transplant(y, y.right)
                    y.right = z.right
                    y.right.p = y
                self.transplant(z, y)
                y.left = z.left
                y.left.p = y
                y.color = z.color
        if(yOriginalColor == BLACK):
            self.deleteFixup(x) 
\end{lstlisting}

\lstset{caption={}}
\lstset{label={lst:alg8}}
\begin{lstlisting}[style = Python]
    def deleteFixup(self, x):
        while(x != self.root and x.color == BLACK):
            if(x == x.p.left):
                w = x.p.right
                if(w.color == RED):
                    w.color = BLACK
                    x.p.color = RED
                    self.leftRotate(x.p)
                    w = x.p.right
                if(w.left.color == BLACK and w.right.color == BLACK):
                    w.color = RED
                    x = x.p
                else:
                    if(w.right.color == BLACK):
                        w.left.color = BLACK
                        w.color = RED
                        self.rightRotate(w)
                        w = x.p.right
                    w.color = x.p.color
                    x.p.color = BLACK
                    w.right.color = BLACK
                    self.leftRotate(x.p)
                    x = self.root
            else:
                w = x.p.left
                if(w.color == RED):
                    w.color = BLACK
                    x.p.color = RED
                    self.rightRotate(x.p)
                    w = x.p.left
                if(w.right.color == BLACK and w.left.color == BLACK):
                    w.color = RED
                    x = x.p
                else:
                    if(w.left.color == BLACK):
                        w.right.color = BLACK
                        w.color = RED
                        self.leftRotate(w)
                        w = x.p.left
                    w.color = x.p.color
                    x.p.color = BLACK
                    w.left.color = BLACK
                    self.rightRotate(x.p)
                    x = self.root
        x.color = BLACK
\end{lstlisting}
\lstset{caption={transplant函数}}
\lstset{label={lst:alg9}}
\begin{lstlisting}[style = Python]
    def transplant(self, u, v):
        if(u.p == self.__nil):
            self.root = v
        elif(u == u.p.left):
            u.p.left = v
        else:
            u.p.right = v
        v.p = u.p  
\end{lstlisting}


\subsection{打印路线、时间与换乘次数}
\begin{enumerate}
	\item 其他函数的实现大体基于以上核心函数，完成了各种功能。具体请参见源代码。
	\item 另外还配套了文件读入等辅助函数，帮助实现本PJ要求的功能。
\end{enumerate}


\section{用户UI的设计与实现}
\begin{enumerate}
	\item 用户UI基于python的tkinter库。
	\item 创建了输入输出框并绑定函数事件，让UI类拥有一棵树的对象，代用户操作这棵树。
	\item UI实现请参见源代码，不加赘述。
\end{enumerate}	

\end{document}