\documentclass[12pt,letterpaper]{article}
\usepackage{fullpage}
\usepackage[top=2cm, bottom=4.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd}
\usepackage{lastpage}
\usepackage{enumerate}
\usepackage{fancyhdr}
\usepackage{mathrsfs}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{float}
\usepackage{longtable}
\usepackage[UTF8]{ctex}
\usepackage[utf8]{inputenc}
\usepackage{subfigure}
\usepackage{amsmath}

\hypersetup{%
	colorlinks=true,
	linkcolor=blue,
	linkbordercolor={0 0 1}
}

\renewcommand{\familydefault}{\rmdefault}
\renewcommand\lstlistingname{代码}
\renewcommand\lstlistlistingname{Algorithms}
\def\lstlistingautorefname{Alg.}

\lstdefinestyle{C++}{
	language        = C++,
	frame           = single, 
	basicstyle      = \footnotesize,
	keywordstyle    = \color{blue},
	numbers         = none,
	stringstyle     = \color{orange},
	commentstyle    = \color{red}\ttfamily
	funtionstyle    = \color{purple},
	numbers         = left,
	columns         = fixed,
	xleftmargin		= 0em,
}

\lstdefinestyle{Python}{
	language        = Python,
	frame           = single, 
	basicstyle      = \footnotesize,
	keywordstyle    = \color{blue},
	numbers         = none,
	stringstyle     = \color{orange},
	commentstyle    = \color{red}\ttfamily
	funtionstyle    = \color{purple},
	numbers         = left,
	columns         = fixed,
	xleftmargin		= 0em,
}

\setlength{\parindent}{0.0in}
\setlength{\parskip}{0.0in}

\newcommand\course{数据结构}
\newcommand\hwnumber{2实验报告}                  
\newcommand\NetIDa{朱奕新}
\newcommand\NetIDb{19307090029}         

\pagestyle{fancyplain}
\headheight 35pt
\lhead{\NetIDa}
\lhead{\NetIDa\\\NetIDb}               
\chead{\textbf{\Large Project \hwnumber}}
\rhead{\course \\ 2021年12月21日}
\lfoot{}
\cfoot{}
\rfoot{\small\thepage}
\headsep 1.5em

\begin{document}
	\section{项目说明}
\begin{enumerate}
	\item 本次实验使用Python语言，实现了Bellman-Ford与Dijkstra两种单源最短路径算法。
	\item 程序分为普通版和UI版。普通版在控制台输入和输出；UI版则用一个UI界面与用户互动，具体使用方法请参见Readme.md文件。两个版本核心算法思想与实现没有本质不同，仅仅是函数返回结果的形式有差异。
	\item 本实验报告以普通版代码为例进行设计的介绍。
\end{enumerate}	
\section{设计思路与实现细节}
\subsection{点类、边类与图类}
\begin{enumerate}
	\item 一个结点需要保存它自身的信息，包括名字、当前距离源的距离，还需要上一次换乘站、从上一次换乘站到此站点的线路以及换乘次数。另外为了之后算法使用，还需要重载小于号运算符。
	\item 一条边需要其起点和终点的引用，还需要知道自身的权重以及自己是几号线。
	\item 一个图需要知道自己的点、自己的边，并提供一个边的名字到边在边列表中下标的字典。
\end{enumerate}
\lstset{caption={结点类}}
\lstset{label={lst:alg1}}
\begin{lstlisting}[style = Python]
class Vertex:
    def __init__(self, newName):
        self.name = newName
        self.d = 10000
        self.lastChange = None
        self.lastLine = -1
        self.changeTime = 0

    def __lt__(self, other):
        if(self.d != other.d):
            return self.d < other.d
        elif(self.changeTime < other.changeTime):
            return True
        else:
            return False
\end{lstlisting}
\lstset{caption={边类}}
\lstset{label={lst:alg2}}
\begin{lstlisting}[style = Python]
class Edge:
    def __init__(self, newU, newV, newW, newLine):
        self.u = newU
        self.v = newV
        self.w = newW
        self.line = newLine
\end{lstlisting}
\lstset{caption={图类}}
\lstset{label={lst:alg3}}
\begin{lstlisting}[style = Python]
class Graph:
    def __init__(self):
        self.vertices = []
        self.edges = []
        self.dic = {}
        self.readIn()
\end{lstlisting}
\subsection{边的松弛}
\begin{enumerate}
	\item 边的松弛是最关键的核心代码。作为边类的成员函数，一条边通过比较通过本边去终点和当前去终点的情况，选择其中一种。
\end{enumerate}
\lstset{caption={边的松弛函数}}
\lstset{label={lst:alg4}}
\begin{lstlisting}[style = Python]
    def __relaxCore(self):
        self.v.d = self.u.d + self.w
        if(self.u.lastLine == self.line):
            self.v.lastChange = self.u.lastChange
            self.v.lastLine = self.u.lastLine
            self.v.changeTime = self.u.changeTime
        else:
            self.v.lastChange = self.u
            self.v.lastLine = self.line
            self.v.changeTime = self.u.changeTime + 1

    def relax(self):
        if((self.u.d + self.w) < self.v.d):
            self.__relaxCore()
            return True
        elif((self.u.d + self.w) == self.v.d):
            if(self.u.lastLine == self.line):
                newChangeTime = self.u.changeTime
            else:
                newChangeTime = self.u.changeTime + 1
            if(newChangeTime < self.v.changeTime):
                self.__relaxCore()
            return True
        else:
            return False    
\end{lstlisting}

\subsection{Bellman-Ford算法}
\begin{enumerate}
	\item 传统的Bellman-Ford算法的方法是对所有的边进行V-1次松弛。但对于本次PJ来说太慢了，于是我们考虑改进。
	\item 事实上，在每一轮中，只需要松弛那些以“上一轮有过更新的结点”为起点的边即可。直到没有边可以松弛。
	\item 最后，Bellman-Ford算法函数作为一个图类的函数存在。
\end{enumerate}
\lstset{caption={Bellman-Ford算法函数}}
\lstset{label={lst:alg5}}
\begin{lstlisting}[style = Python]
    def bellmanFord(self, name):
        self.initialize(name)
        last = []
        last.append([])
        last.append([])
        last[0].append(name)
        for i in range(0, len(self.dic)):
            last[1 - (i % 2)] = []
            for aname in last[i % 2]:
                for edge in self.edges[self.dic[aname]]:
                    if(edge.relax() and edge.v.name not in last[1 - (i % 2)]):
                        last[1 - (i % 2)].append(edge.v.name)   
\end{lstlisting}

\subsection{Dijkstra算法}
\begin{enumerate}
	\item 传统的Dijsktra算法的方法是先将所有点都放入一个优先队列中，然后逐个弹出，处理后放到已处理的列表中。
	\item 本程序将其改进为优先队列内起先只有起点，然后在每一轮中，如果松驰过的边的终点不在队列中也不在处理过的列表中，将其加入队列。
	\item 最后，Dijkstra算法函数作为一个图类的函数存在。
\end{enumerate}
\lstset{caption={Dijkstra算法函数}}
\lstset{label={lst:alg6}}
\begin{lstlisting}[style = Python]
    def dijkstra(self, name):
        self.initialize(name)
        a = []
        b = []
        b.append(self.vertices[self.dic[name]])
        while(len(b) > 0):
            b.sort()
            u = b[0]
            b.pop(0)
            a.append(u)
            for edge in self.edges[self.dic[u.name]]:
                if(edge.v not in a):
                    edge.relax()
                    if(edge.v not in b):
                        b.append(edge.v)   
\end{lstlisting}


\subsection{打印路线、时间与换乘次数}
\begin{enumerate}
	\item 因为已经在每一站的结点，都保存了上一次换乘站、从上一次换乘站到此站点的线路，所以打印线路是容易的。
	\item 另外换乘次数与时间长短不同，不具有无后效性的动态规划性质。为了正确计算出换乘次数，在读入线路时将各条地铁线路都补成了完全图，为此只需改变读入图的函数readIn()，请参见源代码，不加赘述。
\lstset{caption={导航，并打印路线、时间与换乘次数（以Bellman-Ford为例）}}
\lstset{label={lst:alg7}}
\begin{lstlisting}[style = Python]
    def getRouteContinue(self, endStation):
        k = self.dic[endStation]
        now = self.vertices[k]
        ans = now.name
        if(now.lastChange is None):
            ans = "-Line " + str(self.edges[self.dic[endStation]][0].line) + \
             "-" + ans
        while(now.lastChange is not None):
            if(now.lastChange.lastChange is not None):
                ans = now.lastChange.name + "-Line " + \
                    str(now.lastLine) + "-" + ans
            else:
                ans = "-Line " + \
                    str(now.lastLine) + "-" + ans
            now = now.lastChange
        return ans

    def navigateBellmanFord(self, line):
        all = line.split()
        totalChangeTimes = 0
        totalTime = 0
        totalRoute = all[0]
        if(len(all) < 2):
            print("Please enter at least two stations!")
            return
        for i in range(0, len(all)-1):
            myGraph.bellmanFord(all[i])
            totalRoute = totalRoute + myGraph.getRouteContinue(all[i+1])
            totalTime = totalTime + myGraph.getTime(all[i+1])
            totalChangeTimes = totalChangeTimes + \
                myGraph.getChangeTimes(all[i+1])
        print(totalRoute)
        print("Expected time:", totalTime, "minutes")
        print("Expected to change:", totalChangeTimes, "times")
\end{lstlisting}	
\end{enumerate}


\section{用户UI的设计与实现}
\begin{enumerate}
	\item 用户UI基于python的tkinter库。
	\item 创建了输入输出框并绑定函数事件，让UI类拥有一个图的对象，代用户操作这幅图。
	\item UI实现代码多但不含算法相关内容，请参见源代码，不加赘述。
\end{enumerate}	

\end{document}